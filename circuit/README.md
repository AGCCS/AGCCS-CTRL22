

Circuit
=======

The [schematics](agccs-ctrl22-schematics.pdf ) proposed here have been derived from the [SmatEVSE project](https://github.com/SmartEVSE) with a number of modifications in order to

- have an AVR uC from the ATmega series to attract developers from the Arduino community;
- have an ESP32 for networked wireless communications;
- enable/disable any of the three supply phases separately for improved load balancing;
- integrate power monitoring for improved load balancing;
- have a signal realy to virtually unplug/plug the EV to wake it from "sleep"; 
- layout with hand soldering in mind so we can build our own.

When we started AGCCS, we thought of modding SmartEVSE units to our specific needs. However, it became soon clear that this is not vialabe, so we decided to design our own board.  

The original adaption to address our requirements was developed in course of the BA thesis *Entwicklung, Aufbau und Test einer Ladeeinrichtung f√ºr Elektrofahrzeuge nach IEC62169* by Pascal Thurnherr at FAU/Erlangen and has been published in [this project](https://github.com/dreadnomad/FGCCS-Ctrl22). The present repository is a strip down to the essentials. You may want to inspect the original sources; in particular the [BA thesis](../doc/Bachelorarbeit_Pascal_Thurnherr.pdf) includes a convenient summary of the electrical specifications from the CCS standard IEC-62196, as far as relevant for the project at hand.

# Theory of Operation in a Nutshell

We use an ATmega 4808 AVR uC to control the charging process. Its core tasks are to

- operate the mains relays to turn on/off individual phases of the charging outlet;
- generate the control pilot signal (CP) to indicate to the car the amount of power available;
- read back the buffered CP signal to figure the status of the car (e.g. present, charging);
- read the proximity pilot (PP) to figure the current limit implied by the charging cable;
- read back the current actually drawn.    

<img src="../images/circuit.png" alt="Circuit Overview" style="zoom:67%;" />

For the AVR, we provide the firmware [../ctrl22](../ctrl22/) which is configured via a simple human readable protocol on the serial port TX0/RX0, accessible via J4 also for development and testing. **Note that our circuit is 3.3V and you will hence need a 3.3V USB-to-serial converter or a suitable level shifter to access J4.** Once configured, the AVR safely controls the charging process in a stand-alone fashion. The optional ESP32 is utilised to set up a wireless mesh network such that a remote server can re-configure the AVR, e.g. set power limits, enable/disable individual mains phases.  The programming header J5 is used to bootstrap firmware installation (details given below). Once set, further firmware updates can be organised by the remote host, e.g., by the utility `dmctrl.py`; see [../utils](../utils/). 



# Functional Units

Our circuit consists of a number of largely independent functional components that each implement a specific aspect of the charging process. Have the [schematics](agccs-ctrl22-schematics.pdf ) at hand for the following walk through.

**Control Pilot (CP).** The CP signal implements a bidirectional communication with the EV. The charging station outputs a rectangular PWM signal at 1kHz at an amplitude of +/- 12V. This includes the special case of frequency 0Hz, where we output constantly +12V. The output stage for the PWM signal is implemented by the general purpose OpAmp LM7332, labeled U11B. It is wired as a comparator and thus converts the 0V/3.3V PWM signal generated by the AVR via terminal PWM_Out to the required +/-12V level. By the output resistor R23, the effective impedance is reduced to 1k. Thus, if the EV draws a load on the CP signal, the level will lower according  to the effective load impedance. The second half of the LM7332, labeled U11A, reads the actual level of the CP signal and buffers it for reading via an ADC of the AVR. E.g., if the EV imposes an effective load of 1k during the active duty cycle, the +12V will reduce to +6V. The relevant standard specifies the levels 12V (no car present), 9V (car presents), 6V (car ready to charge or charging) and 3V (ventilation required), each with a certain tolerance. In turn, once the EV has been detected by a drop down from 12V to 9V, the charging station applies a certain duty-cycle by which the the EV is informed how much current it may draw for charging. Here, the range  of 10% up to 85% linearly corresponds to the range 6A to 80A. It is by specification only that the care does not use more power, i.e., there is no active current control/limitation in the charging station, mains is forwarded by simple connectors directly to the EV.

**Proximity Pilot (PP).** Charging cables come at a limited capacity, which is encoded by a resistor in the plug to pull the PP line to ground. Our circuit applies a known reference voltage at a known impedance to the PP line a forwards the voltage drop to an ADC of the AVR via the line PP. Thus, the AVR can decode the voltage reading to conclude the cable capacity.

**Current Monitoring.** Our circuit reads back from external current transformers (CT1, CT2, CT3) in order to measure the AC current actually drawn on each individual phase L1, L2 and L3. We envisage that this will provide us interesting options in the later development of different load-balancing schemes. The current transformers are mounted such that the each individual phase runs through the respective transformer. The induced voltage is then approx. linear to the current drawn from the that phase. This voltage is forwarded to the AVR for regular sampling such that the RMS value can be calculated. Although this construct can not be expected to measure the current overly precise, we can detect when the current starts to drop and hence adjust the PWM signal on CP accordingly. Thus, the overall available power can be re-allocated to other charging stations. If you consider current motinoring for billing puposes, you should use an external calibrated meter. If so, get one with RS485 so you can attach it to our circuit and eliminate the need of the current transformers.

**Cable Lock.** The charging cable must not be unplugged while charging. For this reason, conform EV charging outlets have a mechanical lock to hold on the cable. We heard of different styles of locks, however, the principle of operation appears to be all the same. The lock has two main connectors. Depending on the polarity, the lock is engaged or released. Our circuit utilises the general purpose two channel MOSFET driver FAN3214TMX  U5 to implement this feature. With input A logic high and input B logic low it actively drives the external line Lock_W to 12V and the external line Lock_R to GND. Likewise, A logic low and  B logic high does the converse. How to wire the lock correctly is easily figured by experiment. In order for the AVR to figure the lock state, the lock is also equipped with a contact, which typically is closed when the lock is closed. To save on wiring, we set A and B both to logic high when not operating the lock, so we can route 12V via the contact back to the AVR in order to sense line Lock_B. The typical overall setup is

```
Lock_W >---------------------[ actuator ] ---+
                                             |
Lock_R >-------------------------------------+
                                             |
Lock_B <---------------------[ contact ]-----+
```

Here it is assumed that the lock closes when Lock_R is driven to 12V while Lock_W is driven to GND. 

**Power Rails**. Our circuit generates the relevant power rails +12V, -12V and +3.3V in the usual manner using two cascaded switching regulators and a voltage inverter. The +12V rail is obtained by an integrated component directly from mains. We have opted for 800mA as a reasonable maximum rating. However, the lock motor (or solenoid) will on operation draw up to 3A. Thus, we buffer the 12V line via the Schottky diode D12 and the capacitor C12 [rated 15000uF]  with the current limiting resistor R3-R6 [typ. 25R]. The resistor limits the maximum current on the 12V rail to about 500mA while the low voltage across D12 assures a charge to almost 12V. Since the closing or opening of the lock only takes a view ms [we experienced approx. 20ms], the mechanism is effectively driven by the energy held up in the capacitor C12. As a side effect, this construct allows us to address brown-out situations: at power loss during charging we shall release the lock. Since power loss may be caused by issues with the charging process in conjunction with mandatory leakage current detection this scenario is more likely than it appears and being locked on power failure would make our clients really unhappy. We therefor generate the brown-out signal  BOT when the 12V rail falls below approx. 10V, leaving the AVR time to release the lock via the remaining charge of capacitor C12. The minimum dimension of C12 will crucially depend on the actual lock.  **Not all locks are the same:** if you plan to use a lock, you should check on the values of C12 and R3-R6. Charge C12, disconnect power and test whether you can open/close the lock. If you plan on additional units living on the 12V rail, you may want to increase R3-R6 in order to reduce the current drawn while charging C12.

**Digital IOs.** Our circuitry includes digital IOs for an operator button, an operator indicator (LED)  and to individually control each of the three phases L1, L2 and L3 via external contactors, driven by the SSRs  U1, U2 and U3. In addition, we have included the signal relays U12 and U13 to virtually disconnect the EV from the charging station. Since certain EVs will "fall to sleep" when charging does non commence within a certain amount of time, the signal relay becomes relevant when charging by schedule or power allocation by an external agent; e.g. only start charging when solar power is available. 

# Installing Firmware (first time only)

To get bootstrapped, we need to install an initial version of firmware for both the AVR uC and the ESP32 SoC. For this purpose, our board is equipped with the custom 8-pin header J5. For your own convenience, we propose that you set up a programming adaptor following these  [schematics](agccs-j5adaptor-schematic.pdf ). 

|  Fnct.   | Pin  | Pin  |  Fnct.   |
| :------: | :--: | :--: | :------: |
| AVR-UPDI |  1   |  2   |   GND    |
| ESP-TX0  |  3   |  4   |   3.3V   |
| ESP-RX0  |  5   |  6   | ESP-IO15 |
| ESP-IO0  |  7   |  8   |  ESP-EN  |



### AVR Firmware/Bootloader

The ATmega4808 used in our project is a modern incarnation of the ATmega series, and in many aspects more closely related to the XMega series than to clasical ATmegas. You will need a fairly recent version of `avr-gcc`, `avr-libc` and `avr-binutils` (verified with versions 7.3, 2.0.0 and 2.26, respectively):

- for Linux an appropriate toolchain should be supplied by your distribution (verified for Debian; should be the same for many popular Debian derivates);
- for Mac OSX and Windows, the most pragmatic way to get a recent toolchain is to borrow it from an up-to-date Arduino installation (look for `_where_ever_Ardiono_is/Java/hardware/tools/avr/bin/` and set your `PATH` Variable accordingly. 

Another speciality of the XMega series inherited by the ATmega4808 is that they are natively programmed via the so called UPDI one-pin interface. The official programmer Atmel ICE ($100+) works fine with Windows and Atmel AVR Studio (Version 7 or later) and provides professional grade debugging facilities. However, at the time of writing, the Atmel ICE is not well supported by mainstream `avrdude` and may not be accessible via Linux/Mac OSX. Fortunately, the [`pyudpi project`](https://github.com/mraardvark/pyupdi) provides a low-cost alternative which only needs an of the shelf USB-to-serial converter and a single 4.7K resistor --- we used this approach with no problems at all on Mac OSX and Linux. **Again: you will need a 3.3V USB-serial converter - do not trust the labels, use your scope/meter - otherwise risk to fry your AVR**.

Short instructions:

- set up the wiring
  ```
  USB-Serial-TX>---[4.7K]--->+<>AVR-UPDI (aka connector J5 pin 1)
                             |
  USB-Serial-RX>-------------+
  USB-Serisl-GND<>------------<>GND  (aka connector J5 pin 2)
  ```
  
- get   [`pyudpi`](https://github.com/mraardvark/pyupdi)from Github; the 2021-02 version installs via `pip` and requires python3

- get some device specs and check the connection

  ```
  pyupdi.py -d mega4808 -c /dev/{SOME_USB_SERIAL_DEV} -b 115400 -i
  ```

- read fuses 

  ```
  pyupdi.py -d mega4808 -c /dev/{SOME_USB_SERIAL_DEV} -b 115400 -fr
  ```

- write fuses

  ```
  pyupdi.py -d mega4808 -c /dev/{SOME_USB_SERIAL_DEV} -b 115400 -fs {ADDRESS}:{VALUE}
  ```

   {ADDRESS}:{VALUE} is specified in the output format of `-fr`, e.g.,  `8:0x02` to set BOOTEND to 0x02 as propsoed below)

- program flash memory, e.g. the Optiboot bootloader

  ```
  pyupdi.py -d mega4808 -c /dev/{SOME_USB_SERIAL_DEV} -b 115400 -f {OPTIBOOT_FOR_ATM4808}.hex
  ```

Although you can flash any firmware via the routine described above, we need a bootloader for our project such that later firmware updates can be organised remotely. We use Optiboot for its compliance with the Arduino toolchain. Get your original copy of [Optiboot](https://github.com/Optiboot) or use the `.hex` file provided in our repository. 

**Note:** in flash, Optiboot is located in the range from 0x0000 to 0x1ff and thus takes 512bytes. Hence if you use Optiboot, the `BOOTEND` fuse of the ATmega4808 needs to be set to 0x02. The overall setting of fuses depends of the actual firmware. For the provided firmware [ctrl22.c](../ctrl22/) we use the following settings

| address:value | fuse     | comments                                                     |
| ------------- | -------- | ------------------------------------------------------------ |
| 0:0x00        | WDTCFG   | default 0x00, no watchdog                                    |
| 1:0x00        | BODCFG   | default 0x00, test for1.8V@1kHz, disabled (see BOD.CTRLA)    |
| 2:0x02        | OSCLOCK  | default 0x02, use 20MHz oscillator (which we later divide by 2) |
| **5:0xC9**    | SYSCFG0  | default 0xE4, no application CRC, **have RESET pin**, **keep EEPROM on flash erase** |
| 6:0x06        | SYSCFG1  | default 0x07, 64ms start-up-time on power on                 |
| 7:0x00        | APPEND   | defaut 0x00, no explicit data section                        |
| **8:0x02**    | BOOTEND  | default 0x00, **have 2x256bytes bootloader**                 |
| 10:0xC5       | LOCKBITS | default 0xC5, no locks, i.e., UPDI fully enabled             |





### ESP32 Firmware

The ESP32 SoC is far more advanced than a plain AVR uC. It has a built in two-level boot loader and is programmed via the serial interface TX0/RX0. To enter boot loader mode, IO0 must be set low at the time when EN becomes high (EN acts as inverted RESET, and IO0 selects the boot mode).

Short instructions:
- set up the ESP32-MDF SDK and compile the firmware `demesh`; see [../demesh](../demesh/) for a concise introductions; 
- set up the wiring
  ```
  USB-Serial-TX>------------->ESP-RX0  (aka connector J5 pin 5)
  USB-Serial-RX<-------------<ESP-TX0  (aka connector J5 pin 3)
  USB-Serisl-GND<>---+------<>GND      (aka connector J5 pin 2)
                     |
                     +-[/]--<>ESP-IO0  (aka connector J5 pin 7)
                     |
                     +-[/]--->ESP-EN   (aka connector J5 pin 8)
  ```
- to flash the `demesh` firmware
  - set ESP-EN and ESP-IO0 to low (on our adaptor: press the black and the grey button)
  - set ESP-EN to not-connected (on our adaptor: release the black button)
  - run `make flash`
  - set ESP-IO0 to not-connected (on our adaptor: release all buttons)
  

This is effectively the same procedure as with common ESP32 dev-boards such as NodeMCU, except that dev-boards will have convenient key-switches built-in while we need to do some external wiring. **One last word of warning: make sure your USB-to-Serial converter  is 3.3V.**


# Developing/Testing AVR Firmware

Assuming that you have installed Optiboot as described above, application firmware can be installed and tested via the J4 header in Arduino style, i.e., serial debugging via a terminal emulation and firmware flashing over the same serial line using `avrdude -carduino`. If you go this path, we recommend you set up a simple adaptor including a key-switch on the AVR reset-line to conveniently enter boot loader mode, e.g.

```
USB-Serial-RX<-------------<AVR-TX0  (aka connector J4 pin 2)
USB-Serial-TX<-------------<AVR-RX0  (aka connector J4 pin 3)
USB-Serisl-GND<>---+------<>GND      (aka connector J4 pin 1)
                   |
                   +-[/]--<>AVR-RST  (aka connector J4 pin 4)

```

**Advanced Topic:** feel free to get an USB-to-Serial converter with DTR and wire DTR via an high-pass strategically to AVR-RST; e.g., copy the original Arduino schematics in this regard.  Your AGCCS board is then conveniently one-click programmable from the Arduino IDE (using the [MegaCoreX](https://github.com/MCUdude/MegaCoreX) extension to support the ATmega4808).

However, if you have installed the ESP32 with the provided firmware `demesh`, there is an even more convenient and --- given that we are running on mains power --- more safe alternative. On power-on, `demesh` reads IO15. When pulled down to GND it chooses to boot into *target-development mode*. In this mode it will not setup a wifi mesh network but instead act as an access point and provide a transparent telnet passthrough of the AVR serial port TX0/RX0 incl. the Optiboot boot loader. Thus, we can develop/test the AVR firmware largely independently from the more involved wifi mesh but still have the convenience of "no wires from inside the charging station directly to the computer".

After connecting with the access point, the debug server can be accessed via telnet on the standard port 23; e.g.

```
gtelnet 192.168.4.1
```

The IP address, the SSID (default `DebugAVR`) and the WPA2 password are configured within `demesh`; see [../demesh](../demesh/). To inspect available commands for the provided AVR firmware, type `? [CR]`. To exit the session, type `Ctrl-Q` or `Ctrl-D`.

To access the AVR bootloader, the alternative port 2323 is provided. On connections, it resets the AVR to enter Optiboot an can thus be programmed via `avrdude -carduino`. Example 

```
avrdude -patmega4808  -carduino -Pnet:192.168.4.1:2323 -U flash:w:{SOME_HEX_FILE}.hex
```



**Note:** In contrast to the classic ATmega architecture, the ATmega4808 has the boot loader in low address range and, hence, the load address of the application firmware needs to be adjusted accordingly. Optiboot is located in the range 0x0000 to 0x01ff and expects the application to load at 0x0200. This needs to be made explicit when compiling the application firmware, e.g., with the linker directive `--section-start=.text=0x200`. The `makefile` provided with our firmware [../ctrl22](../ctrl22/) will take care about this detail.  



# Hardware Revisions

In this repository we provide the current state of development Rev-1-x and the latest stable version Rev-1-2, both as editable KiCad projects. For documentation purposes, earlier revisions are provided as PDFs for inspection. 

The initial revision Rev-1-0 passed our tests conducted with a first-installation firmware archived in [Pascal Thurnherrs repository](https://github.com/dreadnomad/FGCCS-Ctrl22). Rev-1-1 is an incremental upgrade by the same team, it should be fine too from an electronics perspective. We just have assembled the first prototypes of our intermediate finalist Rev-1-2. All functional units passed basic tests, e.g., we can drive the contactors and generate/read-back the CP signal using the current firmware [ctrl22](../ctrl22/).  Once we have actually charged some EV, we'll tidy up the repository and remove obsolete earlier revisions.



## Revision 1.0

- initial release by Pascal Thurnwald
- thoroughly tested on a component level; e.g, accurate generation of CP and reading the imposed load
- a number of minor hickups, confused pinouts and such; however, with a slightly modded version we actually managed to charge Christophs EV 



## Revision 1.1

- seperate terminals J1/J2 and J6/J7 to fit common housings
- additional protection BAT54S for analog inputs CP, CT0-CT2
- improved pinout of J5 and J4 (programming headers)
- improved pinout on J6/J7 and J1/J2 (simplify external wiring)
- reduced lock resistor from 50 to 25 as learned from Rev-1-0
- clear indication of C16 polarity
- reduced current on button-press

- fixed footprint of power supply
- placed ESP32 on backside for the option of an external antenna



## Revision 1.2

- jet again the push button electronics ... this time we should have got them right

- brown out detection incl. "opening lock on power down"

- improved current reading circuitry to decouple individual phases

- further optimized the spacing in the layour for hans soldering

- general tidying up schematics and the layout 

  

## Revision 1.x

- minor flaws in 1.2 PCB layout  (weak fill on backside layer, not so nice front silk screen)



## Photos (Rev.1.2)

Front (in terms of PCB design; in the enclosure, this becomes the backside)

<img src="../images/hardware_1_2_front.jpeg" style="zoom:50%;"/>

Back (in terms of PCB design; in the enclosure, this becomes the front; note that the 230V/12V converter has not yet been installed, so we can safely power with a bench supply via J3 for testing )

<img src="../images/hardware_1_2_back.jpeg" style="zoom:50%;"/>



**Some notes on assembly.** 0805s can be soldered by hand using a fine tipp and thin solder; same holds for the semiconductors except perhaps the AVR --- solder paste and hot air may be the preference here; since PP is only connected to a resistor within the plug at the charging outlet, we almost certainly may short the relay U12 (and hence not populate it); we never actually used the RS485 option (and hence may not even populate U7); watch out, there are smart and less smart orders in which to solder the individual parts depending on their physical dimensions and locations; most parts are to be soldered to the front side, but some go on the back side --- double check; that tantalum capacitor C16 is polarised (!); regarding functional modules, plan for incremental tests, e.g., first install the 3.3V regulator and run/test from a 12V bench supply, then install the AVR minimalistically and program via UPDI (an indicator LED is useful here, may blink TX2 on the extension connector), then add the ESP32 and set it to target-AVR debug mode; from now on "no wires from the board to your computer", you can further populate/test individual functional modules safely isolated ... a.s.o. ... the 230V/12V converter comes definitely last; clean your glasses, sharpen your tweezers, have fun.  See also our firmware [cytrl22.c](../ctrl22/) for recommendations on first installation.