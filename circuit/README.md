Circuit
=======

The schematics used in this project have been adapted from the [SmatEVSE project](https://github.com/SmartEVSE) with a number of modifications in order to

- have an AVR uC from the ATmega series to attract developers from the Arduino community;
- have an ESP32 for networked wireless communications;
- enable/disable any of the three supply phases seperately for improved load balancing;
- integrate power monitoring for improved load balancing;
- layout with hand soldering in mind so we can build our own.

The original adaption to the above requirements was developed in course of the BA thesis *Entwiclung, Aufbau und Test einer Ladeeinrichting f√ºr Elektrofahrzeuge nach IEC62169* by Pascal Thurnherr at FAU/Erlangen and has been published in [this project](https://github.com/dreadnomad/FGCCS-Ctrl22). The present repository is a strip down to the essentials. You may want to inspect the original sources; in particular the [BA thesis](../doc/Bachelorarbeit_Pascal_Thurnherr.pdf) includes a convenient summary of the electrical specifications from the CCS standard IEC-62196, as far as relevant for the project at hand.



# Theory of Operation in a Nutshell

We use an ATmega 4808 AVR uC to control the charging process. Its core tasks are to

- operate the mains relays to turn on/off individual phases of the charging outlet;
- generate the control pilot signal (CP) to indicate to the car the amount of power available;
- read back the buffered CP signal to figure the status of the car (e.g. present, charging);
- read the proximity pilot (PP) to figure the current limit implied by the charging cable;
- read back the current actually drawn.    

<img src="../images/circuit.png" alt="Circuit Overview" style="zoom:67%;" />

For the AVR, we provide the firmware [../ctrl22](../ctrl22/) which is controlled via a simple human readable protocol on the serial port TX0/RX0, accessible via J4 for development/testing/configuration. **Note that our circuit is 3.3V and you will hence need a 3.3V USB-to-serial converter or a suitable level shifter to access J4.** Once configured, the AVR safely controls the charging process in a stand-alone fashion. The optional ESP32 is utilised to set up a wireless mesh network such that a remote server can configure the AVR, e.g. set power limits, enable/disable individual mains phases.  The programming header J5 is used to bootstrap firmware installation (details given below). Once set, further firmware updates can be organised by the remote host, e.g., by the utility `dmctrl.py`; see [../utils](../utils/). 



# Functional Modules

Our circuit consists of a number of largely indeoendent functional blocks that each controls a particular aspect of the charging process. We give a concise walk through, have the schematics at hand.

**Control Pilot.** The conrol pilot signal (CP) implements a bidirectional communicatiom with the EV. The charging station outputs a recktangular PWM signal at 1kHz at an amplitude of +/- 12V. This includes the special case of frequency 0Hz, where we output constantly +12V. The output stage is implemented by the general purpose OpAmp LM7332, labeled U11B. It is wired as a comperator and thus converts the 0V/3.3V PWM signal generated by the AVR via terminal PWM_Out to the required +/-12V level. By the output resistor R23, the effective impendance is reduced to 1k. Thus, if the EV draws a load on the CP signal, the level will lower according  to ths impedance. The second half of the LM7332, labled U11A, reads the actual level of the CP signal and buffers it for reading via an ADC of the AVR. E.g., if the EV imposes a load of 1k, the +/-12V PWM will efffectively reduce to a +/-6V amplitude. The relevant standard specifies the levels 12V (no car present), 9V (car presens), 6V (car ready to charge) and 3V (ventilation rquired), each with a certain tolerance. In turn, once the EV has been detected by a drop down from 12V to 9V, the charging station applies a certain duty-cycle by which the the EV is informed how much current it may draw forr charging. Here, the range  of 10% up to 85% linearly correspond the range 6A to 80A. It is by specification only that the care does not use more power, i.e., there is no current active control/limitation in the charging station, maines is forearded by simple connector directly to the EV.

**Proximity Pilot.** Charging cables come at capita, which is encoded by e resistor within the plug from proximoity piloy (PP) to ground. Our circuit applies a known reference voltage at a known impedance to the PP line an forwards the voltage drop to an ADC of the AVR via the line PP.

**Current Monitoring.** Our circuit reads brack from current transformers (CTs) in orde to measue the AC current actually drawn on each individual pahse L1, L2 and L3. We envisage, that this will provide us interesting options in the later development of different load-balancing schemes. The current transformers are mounted such that the respective phase rund through the transformer. The induced voltage is then approx. linear to the current drawm from the respective phase. The induced voltage is forwarded to the AVR for regular sampling such that the RMS value can be calculated. Although this constrcut can not be expected to measure the precise current, we can detect when the current starts to drop and hence adjust the PWM signal on CP accordingly. Thus, the overall available prower can be re-allocated to other cahrging stations.

**Cable Lock.** The charging cable must be unplugged while charging. For this reason, conform outlets have a mechanical lock to hold on the cable. We heard of different styles of locks, however, the principle of operation appears to be all the same. The lock has two main connectors. Depending on the polarity, the lock is enables or disabled. Our circuit utilises the general purpose MOSFET driver FAN3214TMX  U5 tio implement this feature. WIth input A logic high and input B logic low it actively drives the external line Lock_W to 12V and the exterbal line Lock_R to GND. Likewise, A logic low and  B logic high does the converse. How to wire lock correctly is easily figured by experiment. In order for the AVR to figure the lock state, the lock is also equipped with a contact, which typically is closed when the lock is closed. To save  on wiring, we set A and B both to logic high when not operating the lock, so we can route 12V via the contact back to the sense line Lock_B. The typical overall setup is

```
Lock_W ---------------------[ actuator ] ---+
																						|
Lock_R -------------------------------------+
                                            |
Lock_B -------------------  [ contact ]-----+
```

Here it is assumed that the lock closed when Lock_R is driven to 12V while Lock_W is driven to GND. 

**Power Rails** Our circuit generates the relevant power rails +12V, +12V and +3.3V in he usual manner using switchihing regulators. The +12V rail derived by an integrated component directly from mains. We have opted for 800mA as a reasonable maximum rating. However, the lock motor (or solenoid) will draw on operation up to 3A. Thus, we buffer the 12V line via the Schottky diod D12 and a capacitor C12 [typ. 15000uF]  with the current limiting resistor R3-R6 [typ. 25R]. The resistor limits the maximum current on the 12V rail to 500mA while the low voltage across D12 assures a charge to almost 12V. Since the closing or opening of the lock only takes  a view ms [typ. 20ms], the mechanism is effectively driven by the energy held up in the capacitor C12. As a side effect, this construct allows us to address brown-out situation: a power loss during charging we shall release the lock. Since power loss may be caused by issues with the charging process together with mandatory leakage current detection this scenario is more likely than it appears and it would make our costumers really unhappe. We therefor generate the brown-out signal  BOT when the 12V rail falls below approx. 10V, leaving the AVR time to release the lock via the charge of the capacitor C12.  

**Digital IOs.** Our circuitry includes digital IOs for an operator button, and operator indicator (LED)  and to individual control each of the three phases L1, L2 and L3. In addition, we have included a signal realy to virtually disconnect the EV from the charging station. This feature is relevant when charging by schedule sind cetain EVs will "fall to sleep" when carging does non comence within a certain amount of time. 



# Installing Firmware (first time only)

To get bootstrapped, we need to install an initial version of firmware for both the AVR uC and the ESP32 SoC. For this purpose, our board is equipped with the custom 8-pin header J5

|  Fnct.   | Pin  | Pin  |  Fnct.   |
| :------: | :--: | :--: | :------: |
| AVR-UPDI |  1   |  2   |   GND    |
| ESP-TX0  |  3   |  4   |   3.3V   |
| ESP-RX0  |  5   |  6   | ESP-IO15 |
| ESP-IO0  |  7   |  8   |  ESP-EN  |



### AVR Firmware/Bootloader

The ATmega4808 used in our project is a modern incarnation of the ATmega series, and in many aspects more closely related to the XMega series. You will need a fairly recent version of `avr-gcc`, `avr-libc` and `avr-binutils` (verified with versions 7.3, 2.0.0 and 2.26, respectively):

- for Linux an appropriate toolchain should be supplied by your distribution (verified for Debian);
- for Mac OSX and Windows, the most pragmatic way to get a recent toolchain is to borrow it from an up-to-date Arduino installation (look for `_where_ever_Ardiono_is/Java/hardware/tools/avr/bin/` and set your `PATH` Variable accordingly. 

Another speciality of the XMega series is that they are natively programmed via the so called UPDI one-pin interface. The official programmer Atmel ICE ($100+) works fine with Windows and Atmel AVR Studio (Version 7 or latest) and provides professional grade debugging facilities. However, at the time of writing, it is not well supported by mainstream `avrdude`. Fortunately, the [`pyudpi project`](https://github.com/mraardvark/pyupdi) provides a low-cost alternative which only needs an of the shelf USB-to-serial converter and a single 4.7K resistor --- and which we used with no problems at all on Mac OSX and Linux. **Again: you will need a 3.3V USB-serial converter**.

Short instructions:

- set up the wiring
  ```
  USB-Serial-TX>---[4.7K]--->+<>AVR-UPDI (aka connector J5 pin 1)
                             |
  USB-Serial-RX>-------------+
  USB-Serisl-GND<>------------<>GND  (aka connector J5 pin 5)
  ```
  
- get `pyudpi.py` from Github; the 2021-02 version installs via `pip` and requires python3

- get some device specs and check the connection

  ```
  pyupdi.py -d mega4808 -c /dev/{SOME_USB_SERIAL_DEV} -b 115400 -i
  ```

- read fuses 

  ```
  pyupdi.py -d mega4808 -c /dev/{SOME_USB_SERIAL_DEV} -b 115400 -fr
  ```

- write fuses

  ```
  pyupdi.py -d mega4808 -c /dev/{SOME_USB_SERIAL_DEV} -b 115400 -fs {ADDRESS}:{VALUE}
  ```

   {ADDRESS}:{VALUE} is specified in the output format of `-fr`, e.g.,  `8:0x02` to set BOOTEND to 0x02 as propsoed below)

- program flash memory, e.g. the Optiboot bootloader

  ```
  pyupdi.py -d mega4808 -c /dev/{SOME_USB_SERIAL_DEV} -b 115400 -f {OPTIBOOT_FOR_ATM4808}.hex
  ```

Although you can flash any firmware via the routine described above, we need a bootloader for our project such that later firmware updates can be organised remotely. We use Optiboot for its compliance with the Arduino toolchain. Get your original copy of [Optiboot](https://github.com/Optiboot) or use the `.hex` file provided in our repository. 

**Note:** in flash, Optiboot is located in the range from 0x0000 to 0x1ff and thus takes 512bytes. Hence if you use Optiboot, the `BOOTEND` fuse of the ATmega4808 needs to be set to 0x02. The overall setting of fuses depends of the actual firmware. For the provided firmware [ctrl22.c](../ctrl22/) we use the following settings

| address:value | fuse     | comments                                                     |
| ------------- | -------- | ------------------------------------------------------------ |
| 0:0x00        | WDTCFG   | default 0x00, no watchdog                                    |
| 1:0x00        | BODCFG   | default 0x00, test for1.8V@1kHz, disabled (see BOD.CTRLA)    |
| 2:0x02        | OSCLOCK  | default 0x02, use 20MHz oscillator (which we later divide by 2) |
| **5:0xC9**    | SYSCFG0  | default 0xC0, no application CRC, **have RESET pin**, **keep EEPROM on flash erase** |
| 6:0x06        | SYSCFG1  | default 0x07, 64ms start-up-time on power on                 |
| 7:0x00        | APPEND   | defaut 0x00, no explicit data section                        |
| **8:0x02**    | BOOTEND  | default 0x00, **have 2x256bytes bootloader**                 |
| 10:0xC5       | LOCKBITS | default 0xC5, no locks, i.e., UPDI fully enabled             |





### ESP32 Firmware

The ESP32 SoC is far more advanced than a plain AVR uC. It has a built in two-level bootloader and is programmed via the serial interface TX0/RX0. To enter bootloader mode, IO0 must be set low at the time when EN becomes high (EN acts as inverted RESET, and IO0 selects the bootmode).

Short instructions:
- set up the ESP32-MDF SDK and compile the firmware `demesh`; see [../demesh](../demesh/) for a concise introductions; 
- set up the wiring
  ```
  USB-Serial-TX>------------->ESP-RX0  (aka connector J5 pin 2)
  USB-Serial-RX<-------------<ESP-TX0  (aka connector J5 pin 3)
  USB-Serisl-GND<>---+------<>GND      (aka connector J5 pin 5)
                     |
                     +-[/]--<>ESP-IO0  (aka connector J5 pin 4)
                     |
                     +-[/]--->ESP-EN   (aka connector J5 pin 8)
  ```
- to flash the `demesh` firmware
  - set ESP-EN and ESP-IO0 to low
  - set ESP-EN to not-connected
  - run `make flash`
  - set ESP-IO0 to not-connected
  

This is effectively the same procedure as with common ESP32 dev-boards such as NodeMCU, except that dev-boards will have convenient key-switches built-in while we need to do some external wiring. 


# Developing/Testing AVR Firmware

Assumimg that you have installed Optiboot as described above, application frimware can be installed and tested via the J4 header in Arduino style, i.e., serial debugging via a terminal emulation and frimware flashing via `avrdude -carduino` over the same serial line. If you go this path, we recommend you set up a simple adaptor including a keyswitch on the AVR reset-line to conveniently enter bootloader mode, e.g.

```
USB-Serial-RX<-------------<AVR-TX0  (aka connector J4 pin 2)
USB-Serial-TX<-------------<AVR-RX0  (aka connector J4 pin 3)
USB-Serisl-GND<>---+------<>GND      (aka connector J4 pin 1)
                   |
                   +-[/]--<>AVR-RST  (aka connector J4 pin 4)

```

**Advanced Topic:** feel free to get an USB-to-Serial converter with DTR and wire DTR via an high-pass strategically to AVR-RST; e.g., copy the original Arduino schematics in this regard.  Your AGCCS board is then conveniently programmable from the Arduino IDE (using [MegaCoreX](https://github.com/MCUdude/MegaCoreX) extension).

However, if you have installed the ESP32 with the provided firmware `demesh`, there is an even more convenient and --- given that we are running on maines power --- more safe alternative. On power-on, `demesh` reads a configurable IO pin (default IO15) to choose to boot into *target-development mode*. In this mode it will not setup a wifi mesh network but instead act as an accesspoint and provide a transparent telnet passthrough of the AVR serial port TX0/RX0 incl. the Optiboot bootloader. Thus, we can develop/test the AVR firmware largely independantly from the more involved wifi mesh but still have the convenience of "no wires from the charging station directly to the computer".

After connecting with the access point, the debug server can be accessed via

```
gtelnet 192.168.4.1
```

The IP address, the SSID and the WPA2 password are configured within `demesh`; see [../demesh](../demesh/)
To inspect available commands for the provided AVR firmware, type `? [CR]`. To exit the session, 
type `Ctrl-Q` or `Ctrl-D`.

To access the AVR bootloader, the alternative port 2323 is provided. On connections, it resets the AVR to enter Optiboot an can thus be programmed via `avrdude -carduino`. Example 

```
avrdude -patmega4808  -carduino -Pnet:192.168.4.1:2323 -U flash:w:{SOME_HEX_FILE}.hex
```



**Note:** In contrast to the classic ATmega architecture, the ATmega4808 has the bootloader in low address range and, hence, the load address of the application firmware needs to be adjusted accordingly. Optibooot is located in the range 0x0000 to 0x01ff and expects firmware to load at 0x0200. This needs to be made explicit when compiling the firmware, e.g., with the linker directive `--section-start=.text=0x200`. The `makefile` provided with our firmware [../ctrl22](../ctrl22/) will take care about this detail.  



# Hardware Revisions

In this repository we currently provide the develoment version Rev-1-2 as an editable KiCad project and the schematics of Rev-1-1 for easy inspection. The initial revision Rev-1-0 passed our tests conducted with an first-installation firmware. Rev-1-1 is an incremental upgrade by the same team, it should be fine from an electronics perspective, too. We are currently ordering/assembilg our intermediate finalist Rev-1-2, keeping our fingers crossed. Once Rev-1-2 has been positively evaluated with our production firmware [ctrl22](../ctrl22/), we'll tidy up the repository and remove obsolete earlier revisions.



## Revision 1.0

- initial release by Pascal Thurnwald
- thouroghly tested on a component level; e.g, accurate generation of CP and readinb the imposed load
- a number of minor hickups, confused pinouts and such; however, with a slightly modded version we actually managed to charge Christophs EV 



## Revision 1.1

- seperate terminals J1/J2 and J6/J7 to fit common housings
- additional protection BAT54S for analog inputs CP, CT0-CT2
- improved pinout of J5 and J4 (programming headers)
- improved pinout on J6/J7 and J1/J2 (simplify external wiring)
- reduced lock resistor from 50 to 25 as learned from Rev-1-0
- clear indication of C16 polarity
- reduced current on button-press

- fixed footprint of power supply
- placed ESP32 on backside for the option of an external antenna



## Revision 1.2

- jet again the push button electronics ... this time we should have got them right
- brown out detection incl. "opening lock on power down"
- improved current reading circuitry to decouple individual phases

- further optimized the spacing in the layour for hans soldering

- general tidying up schmetics and the layout 

  
